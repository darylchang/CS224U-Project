on_ batch-constructing_a b/sup_n +_n /-trees_n :_ algorithm_n and_ its_ performance_n evaluation_n efficient_a construction_n of_ indexes_n is_v very_r important_a in_ bulk-loading_n a_ database_n or_ adding_v a_ new_a index_n to_ an_ existing_v database_n since_ both_ of_ them_ should_ handle_v an_ enormous_a volume_n of_ data_n ._ in_ this_ paper_n ,_ we_ propose_v an_ algorithm_n for_ batch-constructing_ the_ b/sup_n +_n /-tree_n ,_ the_ most_r widely_r used_v index_n structure_n in_ database_n systems_n ._ the_ main_a characteristic_n of_ our_ algorithm_n is_v to_ simultaneously_r process_v all_ the_ key_a values_n to_ be_v placed_v on_ each_ b_n +_n -tree_n page_n when_ accessing_v the_ page_n ._ this_ avoids_v the_ overhead_n due_a to_ accessing_v the_ same_a page_n multiple_a times_n ,_ which_ results_v from_ applying_v the_ b_n +_n -tree_n insertion_n algorithm_n repeatedly_r ._ for_ performance_n evaluation_n ,_ we_ have_v analyzed_v our_ algorithm_n in_ terms_n of_ the_ number_n of_ disk_n accesses_n ._ the_ results_n show_v that_ the_ number_n of_ disk_n accesses_n excluding_v those_ in_ the_ relocation_n process_n is_v identical_a to_ the_ number_n of_ pages_n belonging_v to_ the_ b/sup_n +_n /-tree_n ._ considering_v that_ the_ relocation_n process_n is_v an_ unavoidable_a preprocessing_v step_n for_ batch-constructing_ of_ b/sup_n +_n /-trees_n ,_ our_ algorithm_n requires_v just_r one_ disk_n access_n per_ b_n +_n -tree_n page_n ,_ and_ therefore_r turns_v out_ to_ be_v optimal_n ._ we_ also_r present_v the_ performance_n tendency_n in_ relation_n with_ different_a parameter_n values_n via_ simulation_n ._ finally_r ,_ we_ show_v the_ performance_n enhancement_n effect_n of_ our_ algorithm_n ,_ compared_v with_ the_ one_ using_v repeated_v insertions_n through_ experiments_n